%{
    #include <iostream>
    #include <string>
    #include <fstream>
    #include <vector>
    #include "symtab.hpp"
    #include "generator.hpp"

    using namespace std;

    extern int yylineno;
    extern FILE* yyin;
    int yylex();
    int yyerror(string s);

    Generator* gen;
    Symtab* sym;
    vector<string> code;
%}

%union {
    long long num;
    std::string* pid;
    symbol* sym;
    lbls* lbl;
    forlbl* flbl;
}

%token VAR t_BEGIN END ASSIGN IF THEN ELSE ENDIF
%token WHILE ENDWHILE UNTIL FROM TO DOWNTO ENDFOR
%token <num> REPEAT
%token <flbl> FOR
%token <sym> DO
%token READ WRITE 
%token EQ NEQ LE GE LEQ GEQ 
%token COMMA COLON SEMICOLON LBRACKET RBRACKET
%token ERROR

%token <num> NUM
%token <pid> PIDENTIFIER

%left PLUS MINUS
%left TIMES DIV MOD

%type <sym> value
%type <sym> expression
%type <sym> identifier
%type <lbl> condition

%start program

%%
program     : VAR declarations t_BEGIN commands END                             {gen->gen_end();}
            | t_BEGIN commands END                                              {gen->gen_end();}
            ;

declarations: declarations COMMA PIDENTIFIER                                    {sym->putsym(*$3);}
            | declarations COMMA PIDENTIFIER LBRACKET NUM COLON NUM RBRACKET    {sym->putarr(*$3, $5, $7);}
            | PIDENTIFIER                                                       {sym->putsym(*$1);}
            | PIDENTIFIER LBRACKET NUM COLON NUM RBRACKET                       {sym->putarr(*$1, $3, $5);}
            ;

commands    : commands command
            | command
            ;

command     : identifier ASSIGN expression SEMICOLON                            {gen->gen_assign($1);}
            | IF condition THEN commands                                        {$2=gen->gen_if_else($2);}
              ELSE commands ENDIF                                               {gen->gen_if($2);}
            | IF condition THEN commands ENDIF                                  {gen->gen_if($2);}
            | WHILE condition DO commands ENDWHILE                              {gen->gen_while($2);}
            | REPEAT                                                            {$1=gen->get_offset();}
              commands UNTIL condition SEMICOLON                                {gen->gen_repeat($1, $5);}
            | FOR PIDENTIFIER FROM value TO value DO                            {sym->putit(*$2);
                                                                                 $7=sym->getsym(*$2);
                                                                                 $1=gen->gen_for_start($7, $4, $6, false);}
              commands ENDFOR                                                   {gen->gen_for_end($1, false);
                                                                                 sym->delsym(*$2);}
            | FOR PIDENTIFIER FROM value DOWNTO value DO                        {sym->putit(*$2);
                                                                                 $7=sym->getsym(*$2);
                                                                                 $1=gen->gen_for_start($7, $4, $6, true);}
              commands ENDFOR                                                   {gen->gen_for_end($1, true);
                                                                                 sym->delsym(*$2);}
            | READ identifier SEMICOLON                                         {gen->gen_read($2);}
            | WRITE value SEMICOLON                                             {gen->gen_write($2);}
            ;

expression  : value                                                             {gen->get_value($1);}
            | value PLUS value                                                  {gen->gen_add($1, $3);}
            | value MINUS value                                                 {gen->gen_sub($1, $3);}
            | value TIMES value                                                 {gen->gen_mult($1, $3);}
            | value DIV value                                                   {gen->gen_div($1, $3);}
            | value MOD value                                                   {gen->gen_mod($1, $3);}
            ;

condition   : value EQ value                                                    {$$=gen->gen_eq($1, $3);}
            | value NEQ value                                                   {$$=gen->gen_neq($1, $3);}
            | value LE value                                                    {$$=gen->gen_le($1, $3);}
            | value GE value                                                    {$$=gen->gen_ge($1, $3);}
            | value LEQ value                                                   {$$=gen->gen_leq($1, $3);}
            | value GEQ value                                                   {$$=gen->gen_geq($1, $3);}
            ;

value       : NUM                                                               {$$=sym->get_const($1);}
            | identifier                                                        {$$=$1;}

identifier  : PIDENTIFIER                                                       {$$=sym->get_var(*$1);}
            | PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET                         {$$=sym->get_var(*$1, *$3);}
            | PIDENTIFIER LBRACKET NUM RBRACKET                                 {$$=sym->get_var(*$1, $3);}

%%

int yyerror(string s) {
    cout << s << " at line " << yylineno << endl;
};

int main(int argc, char **argv) {
    if (argc < 2) {
        cerr << "\e[31mError: \e[0mNo input file" << endl;
        return 1;
    }

    FILE *src = fopen(argv[1], "r");

    if (!src) {
        cerr << "\e[31mError: \e[0mCannot open file " << argv[1] << endl;
        return 1;
    }

    sym = new Symtab();
    gen = new Generator(sym);

    yyin = src;
    yyparse();
    fclose(src);

    ofstream output;
    output.open(argv[2] ? argv[2] : "a.out");

    code = gen->get_code();
    //sym->print();
    vector<string>::iterator it;

    for(it = code.begin(); it != code.end(); it++) {
        output << *it << endl;
    }
    output.close();
}
